Is the worker function (in the worker class) running on a separate thread? Is it started using a Thread/ThreadPool/BeginInvoke? This is probably the case, but it's not clear from the code you've provided. Can you show the code that calls radiazerMain? Main.cs?Normally, only one thread in your application runs the GUI event loop (Application.Run() for WinForms, GTK# must have something similar). Only this thread can create and change windows (including all controls/widgets on those windows).The usual way to work around this restriction is by using the Invoke/BeginInvoke calls (in WinForms) on a window/form/control, or in some other way "post" a request to call a function on the GUI thread. The specified callback function is then called on the right thread and can update the GUI.Another option is to expose the worker progress as a public property, and create a Timer (again WinForms, GTK probably has something similar) to periodically read this property and update the GUI.Another thing you can't/shouldn't do: run the worker function on the GUI thread (for example through a direct call from a Window load function or button click handler). This will block the GUI thread - and all event processing including updates - until the worker has finished, resulting in the well known "Application is not responding" error on Windows.Showing a window basically sets a flag. And the window manager willapparently be notified, since it draws the border etc. But the windowitself isn't rendered until the gui loop gets around to it.Here, you keep holding the thread. So it can never get back into the GTKmain loop and thus it will never get around to rendering your window.Unless this is a different thread, but in that case you shouldn't handleGUI elements at all, since the GUI framework is not designed to be used bymore than one thread.You might want to have a look at the BackgroundWorker class to place thework on a separate thread, but leave the GUI interaction to the GUI thread.